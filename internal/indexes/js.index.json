[
  {
    "name": "dependency-vuln.js",
    "size_bytes": 1888,
    "preview_lines": [
      "#!/usr/bin/env node",
      "import { execSync } from 'child_process';",
      "import fs from 'fs';",
      "",
      "export const scanDependencies = async (context = {}) => {",
      "    const verbose = !context.entry_point;",
      "    try {",
      "        let report = { ok: true, vulnerabilities: {} };",
      "        try {",
      "            const out = execSync('npm audit --json', { stdio: ['ignore', 'pipe', 'pipe'], encoding: 'utf8', timeout: 30000 });",
      "            const json = JSON.parse(out);",
      "            report.ok = json.ok;",
      "            if (json.metadata && json.metadata.vulnerabilities) {",
      "                report.vulnerabilities = json.metadata.vulnerabilities;",
      "            }",
      "            if (!report.ok && process.env.SAFE_NPM_AUDIT_FIX === '1') {",
      "                try {",
      "                    execSync('npm audit fix', { stdio: 'inherit' });",
      "                    report.attempted_fix = true;",
      "                } catch (e) {",
      "                    report.attempted_fix = true;",
      "                    report.fix_error = String(e.message || e);",
      "                }",
      "            }",
      "        } catch (e) {",
      "            // Fallback: no audit data",
      "            report.ok = false;",
      "            report.error = String(e.message || e);",
      "        }",
      "        if (!fs.existsSync('reports')) fs.mkdirSync('reports', { recursive: true });",
      "        const pathOut = `reports/dependency_vuln_${Date.now()}.json`;",
      "        fs.writeFileSync(pathOut, JSON.stringify(report, null, 2));",
      "        const result = { success: true, dependency_scan_complete: true, ok: report.ok, report_path: pathOut, attempted_fix: !!report.attempted_fix };",
      "        if (verbose) console.log(JSON.stringify(result));",
      "        return result;",
      "    } catch (e) {",
      "        const fail = { success: false, dependency_scan_complete: false, error: String(e) };",
      "        if (verbose) console.log(JSON.stringify(fail));",
      "        return fail;",
      "    }",
      "};",
      "",
      "export default { scanDependencies };"
    ]
  },
  {
    "name": "external-failure-diagnostic.js",
    "size_bytes": 13629,
    "preview_lines": [
      "#!/usr/bin/env node",
      "/**",
      " * External Failure Diagnostic Frame",
      " * Analyzes external command failures and generates comprehensive recommendations",
      " */",
      "",
      "import fs from 'fs';",
      "import path from 'path';",
      "import { fileURLToPath } from 'url';",
      "",
      "const __filename = fileURLToPath(import.meta.url);",
      "const __dirname = path.dirname(__filename);",
      "",
      "/**",
      " * Analyze external command failures and generate recommendations",
      " * @param {Object} context - Execution context from the framework",
      " * @returns {Object} Analysis results with recommendations",
      " */",
      "export const analyzeFailures = async (context = {}) => {",
      "    const {",
      "        input_data = {},",
      "        parameters = {},",
      "        previous_results = {}",
      "    } = context;",
      "    ",
      "    // Suppress verbose output when called as a frame",
      "    const verbose = !context.entry_point;",
      "    ",
      "    if (verbose) {",
      "        console.log('üî¨ External Failure Diagnostic Analysis');",
      "        console.log('=' * 50);",
      "    }",
      "    ",
      "    try {",
      "        // Extract external failures from previous results",
      "        const externalFailures = extractExternalFailures(previous_results);",
      "        ",
      "        if (externalFailures.length === 0) {",
      "            const result = {",
      "                success: true,",
      "                analysis_complete: true,",
      "                recommendations_generated: true,",
      "                data: {",
      "                    status: 'no_failures',",
      "                    message: 'No external failures detected',",
      "                    recommendations: []",
      "                },",
      "                summary: 'No external command failures found',",
      "                context: {",
      "                    failures_analyzed: 0,",
      "                    recommendations_generated: 0",
      "                }",
      "            };",
      "            ",
      "            if (verbose) {",
      "                console.log(JSON.stringify(result));",
      "            }",
      "            return result;",
      "        }",
      "        ",
      "        // Perform comprehensive analysis",
      "        const analysis = performComprehensiveAnalysis(externalFailures, parameters);",
      "        ",
      "        // Generate recommendations",
      "        const recommendations = generateRecommendations(analysis);",
      "        ",
      "        // Create action plan",
      "        const actionPlan = createActionPlan(analysis, recommendations);",
      "        ",
      "        const result = {",
      "            success: true,",
      "            analysis_complete: true,",
      "            recommendations_generated: true,",
      "            data: {",
      "                status: 'failures_analyzed',",
      "                total_failures: externalFailures.length,",
      "                analysis: analysis,",
      "                recommendations: recommendations,",
      "                action_plan: actionPlan",
      "            },",
      "            summary: `Analyzed ${externalFailures.length} external failures and generated ${recommendations.length} recommendations`,",
      "            context: {",
      "                failures_analyzed: externalFailures.length,",
      "                recommendations_generated: recommendations.length,",
      "                critical_issues: analysis.criticalIssues.length,",
      "                orphan_failures: analysis.orphanFailures.length",
      "            }",
      "        };",
      "        ",
      "        if (verbose) {",
      "            console.log(`‚úÖ Analysis complete: ${externalFailures.length} failures analyzed`);",
      "            console.log(`üìã Generated ${recommendations.length} recommendations`);",
      "            console.log(`üö® Critical issues: ${analysis.criticalIssues.length}`);",
      "            console.log(`‚ö†Ô∏è Orphan failures: ${analysis.orphanFailures.length}`);",
      "        }",
      "        ",
      "        if (verbose) {",
      "            console.log(JSON.stringify(result));",
      "        }",
      "        return result;"
    ]
  },
  {
    "name": "knowledge-hub-updater.js",
    "size_bytes": 16217,
    "preview_lines": [
      "#!/usr/bin/env node",
      "",
      "/**",
      " * Knowledge Hub Auto-Updater",
      " * ",
      " * Scans the codebase and automatically updates the Knowledge Hub",
      " * to ensure it stays current and comprehensive.",
      " */",
      "",
      "import fs from 'fs';",
      "import path from 'path';",
      "import { execSync } from 'child_process';",
      "",
      "class KnowledgeHubUpdater {",
      "    constructor() {",
      "        this.projectRoot = process.cwd();",
      "        this.hubPath = path.join(this.projectRoot, 'KNOWLEDGE_HUB.md');",
      "        this.scanResults = {",
      "            newFiles: [],",
      "            modifiedFiles: [],",
      "            newTools: [],",
      "            newTemplates: [],",
      "            newEndpoints: [],",
      "            newScripts: [],",
      "            newDocumentation: []",
      "        };",
      "    }",
      "",
      "    async updateHub() {",
      "        console.log('üîÑ Updating Knowledge Hub...');",
      "",
      "        try {",
      "            // Scan for new and modified files",
      "            await this.scanCodebase();",
      "",
      "            // Analyze changes",
      "            await this.analyzeChanges();",
      "",
      "            // Update hub content",
      "            await this.updateHubContent();",
      "",
      "            // Generate update report",
      "            await this.generateUpdateReport();",
      "",
      "            console.log('‚úÖ Knowledge Hub updated successfully!');",
      "",
      "        } catch (error) {",
      "            console.error('‚ùå Error updating Knowledge Hub:', error);",
      "            process.exit(1);",
      "        }",
      "    }",
      "",
      "    async scanCodebase() {",
      "        console.log('üìÅ Scanning codebase for changes...');",
      "",
      "        // Get git status for modified files",
      "        try {",
      "            const gitStatus = execSync('git status --porcelain', { encoding: 'utf8' });",
      "            const lines = gitStatus.split('\\n').filter(line => line.trim());",
      "",
      "            lines.forEach(line => {",
      "                const status = line.substring(0, 2).trim();",
      "                const filePath = line.substring(3);",
      "",
      "                if (status === 'A' || status === '??') {",
      "                    this.scanResults.newFiles.push(filePath);",
      "                } else if (status === 'M') {",
      "                    this.scanResults.modifiedFiles.push(filePath);",
      "                }",
      "            });",
      "        } catch (error) {",
      "            console.log('‚ö†Ô∏è  Git not available, scanning all files...');",
      "            await this.scanAllFiles();",
      "        }",
      "    }",
      "",
      "    async scanAllFiles() {",
      "        const directories = [",
      "            'backend',",
      "            'src',",
      "            'tools',",
      "            'scripts',",
      "            'docs',",
      "            'consciousness',",
      "            'OCTOSPINE'",
      "        ];",
      "",
      "        for (const dir of directories) {",
      "            if (fs.existsSync(dir)) {",
      "                await this.scanDirectory(dir);",
      "            }",
      "        }",
      "    }",
      "",
      "    async scanDirectory(dirPath, relativePath = '') {",
      "        const fullPath = path.join(this.projectRoot, dirPath);",
      "        const items = fs.readdirSync(fullPath);",
      "",
      "        for (const item of items) {",
      "            const itemPath = path.join(fullPath, item);"
    ]
  },
  {
    "name": "observability-bootstrap.js",
    "size_bytes": 1152,
    "preview_lines": [
      "#!/usr/bin/env node",
      "import fs from 'fs';",
      "import path from 'path';",
      "",
      "export const bootstrapObservability = async (context = {}) => {",
      "    const verbose = !context.entry_point;",
      "    try {",
      "        const dir = path.join('config', 'observability');",
      "        fs.mkdirSync(dir, { recursive: true });",
      "        const logConf = {",
      "            level: 'info',",
      "            format: 'json',",
      "            fields: ['timestamp', 'level', 'message', 'component', 'requestId']",
      "        };",
      "        const file = path.join(dir, 'logging.json');",
      "        fs.writeFileSync(file, JSON.stringify(logConf, null, 2));",
      "        const result = {",
      "            success: true,",
      "            observability_bootstrapped: true,",
      "            data: { logging_config: file },",
      "            summary: 'Structured logging configuration created'",
      "        };",
      "        if (verbose) console.log(JSON.stringify(result));",
      "        return result;",
      "    } catch (e) {",
      "        const fail = { success: false, observability_bootstrapped: false, error: String(e) };",
      "        if (verbose) console.log(JSON.stringify(fail));",
      "        return fail;",
      "    }",
      "};",
      "",
      "export default { bootstrapObservability };"
    ]
  },
  {
    "name": "remediation.js",
    "size_bytes": 3640,
    "preview_lines": [
      "#!/usr/bin/env node",
      "import fs from 'fs';",
      "import path from 'path';",
      "",
      "function latestFile(dir, prefix) {",
      "    if (!fs.existsSync(dir)) return null;",
      "    const files = fs.readdirSync(dir).filter(f => f.startsWith(prefix)).map(f => ({ f, t: fs.statSync(path.join(dir, f)).mtimeMs }));",
      "    if (!files.length) return null;",
      "    files.sort((a, b) => b.t - a.t);",
      "    return path.join(dir, files[0].f);",
      "}",
      "",
      "function loadJSON(p) {",
      "    try { return JSON.parse(fs.readFileSync(p, 'utf8')); } catch { return null; }",
      "}",
      "",
      "export const generateRemediationPlan = async (context = {}) => {",
      "    const verbose = !context.entry_point;",
      "    try {",
      "        const reportsDir = 'reports';",
      "        const sbomPath = latestFile(reportsDir, 'sbom_');",
      "        const depPath = latestFile(reportsDir, 'dependency_vuln_');",
      "        const secretsPath = latestFile(reportsDir, 'secrets_scan_');",
      "",
      "        const sbom = sbomPath ? loadJSON(sbomPath) : null;",
      "        const deps = depPath ? loadJSON(depPath) : null;",
      "        const secrets = secretsPath ? loadJSON(secretsPath) : null;",
      "",
      "        const actions = [];",
      "        const commands = [];",
      "",
      "        if (deps && deps.ok === false) {",
      "            actions.push({ kind: 'dependency', title: 'Resolve dependency vulnerabilities', priority: 'high' });",
      "            commands.push('npm audit fix');",
      "            commands.push('npm audit fix --force # review breaking changes before running');",
      "        }",
      "",
      "        if (secrets && Array.isArray(secrets.findings) && secrets.findings.length) {",
      "            const high = secrets.findings.filter(f => f.severity === 'high');",
      "            actions.push({ kind: 'secrets', title: `Rotate and remove exposed secrets (${high.length} high)`, priority: 'critical' });",
      "            actions.push({ kind: 'secrets', title: 'Add false-positive patterns to config/security/secrets-allowlist.json', priority: 'medium' });",
      "        }",
      "",
      "        if (sbom && sbom.data && sbom.data.components) {",
      "            actions.push({ kind: 'sbom', title: 'Verify licenses and add SPDX allowlist/denylist', priority: 'medium' });",
      "        }",
      "",
      "        const plan = { generated_at: new Date().toISOString(), inputs: { sbomPath, depPath, secretsPath }, actions, commands };",
      "        if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });",
      "        const out = path.join(reportsDir, `remediation_plan_${Date.now()}.json`);",
      "        fs.writeFileSync(out, JSON.stringify(plan, null, 2));",
      "",
      "        // Standard success result for framework consumption",
      "        const result = {",
      "            success: true,",
      "            remediation_generated: true,",
      "            plan_path: out,",
      "            summary: `Generated remediation plan with ${actions.length} actions`,",
      "            context: { actions_count: actions.length, commands_count: commands.length }",
      "        };",
      "",
      "        // When run as a frame, ONLY emit the success result",
      "        if (context && context.entry_point) {",
      "            console.log(JSON.stringify(result));",
      "            return result;",
      "        } else {",
      "            // When run standalone, emit both success and plan details",
      "            console.log(JSON.stringify(result));",
      "            console.log(JSON.stringify(plan));",
      "            return plan;",
      "        }",
      "    } catch (e) {",
      "        const fail = {",
      "            success: false,",
      "            remediation_generated: false,",
      "            error: String(e),",
      "            summary: 'Remediation plan generation failed'",
      "        };",
      "        if (verbose) console.log(JSON.stringify(fail));",
      "        return fail;",
      "    }",
      "};",
      "",
      "if (import.meta.url === `file://${process.argv[1]}`) {",
      "    generateRemediationPlan();",
      "}"
    ]
  },
  {
    "name": "sbom-license.js",
    "size_bytes": 3975,
    "preview_lines": [
      "#!/usr/bin/env node",
      "// SBOM & License frame (ESM)",
      "import fs from 'fs';",
      "import path from 'path';",
      "",
      "const readJsonIfExists = (p) => {",
      "  try {",
      "    if (fs.existsSync(p)) return JSON.parse(fs.readFileSync(p, 'utf8'));",
      "  } catch { }",
      "  return null;",
      "};",
      "",
      "const readLinesIfExists = (p) => {",
      "  try {",
      "    if (fs.existsSync(p)) return fs.readFileSync(p, 'utf8').split(/\\r?\\n/).filter(Boolean);",
      "  } catch { }",
      "  return [];",
      "};",
      "",
      "export const generateSbom = async (context = {}) => {",
      "  const verbose = !context.entry_point;",
      "  try {",
      "    const rootPkg = readJsonIfExists('package.json') || {};",
      "    const backendPkg = readJsonIfExists(path.join('backend', 'package.json')) || {};",
      "    const reqTxt = readLinesIfExists('requirements.txt');",
      "    const backendReq = readLinesIfExists(path.join('backend', 'requirements.txt'));",
      "",
      "    const npmDeps = Object.entries({ ...(rootPkg.dependencies || {}), ...(backendPkg.dependencies || {}) })",
      "      .map(([name, version]) => ({ ecosystem: 'npm', name, version, license: 'UNKNOWN' }));",
      "    const pyDeps = [...reqTxt, ...backendReq]",
      "      .map(line => line.trim())",
      "      .filter(line => line && !line.startsWith('#'))",
      "      .map(line => ({ ecosystem: 'pypi', name: line.split('==')[0], version: (line.split('==')[1] || 'UNKNOWN'), license: 'UNKNOWN' }));",
      "",
      "    const sbom = {",
      "      metadata: { generatedAt: new Date().toISOString(), version: '0.1', tool: 'AZ-Interface SBOM Frame' },",
      "      components: [...npmDeps, ...pyDeps]",
      "    };",
      "",
      "    // Simple SPDX policy",
      "    const policyPath = path.join('config', 'security', 'spdx-policy.json');",
      "    const exceptionsPath = path.join('config', 'security', 'spdx-exceptions.json');",
      "    let allow = ['MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause'];",
      "    let deny = ['GPL-3.0-only', 'AGPL-3.0-only'];",
      "    let exceptions = [];",
      "    try {",
      "      if (fs.existsSync(policyPath)) {",
      "        const p = JSON.parse(fs.readFileSync(policyPath, 'utf8'));",
      "        if (Array.isArray(p.allow)) allow = p.allow;",
      "        if (Array.isArray(p.deny)) deny = p.deny;",
      "      }",
      "      if (fs.existsSync(exceptionsPath)) {",
      "        const ex = JSON.parse(fs.readFileSync(exceptionsPath, 'utf8'));",
      "        if (Array.isArray(ex.allow)) exceptions = ex.allow; // entries like \"pkg\" or \"pkg@version\"",
      "      }",
      "    } catch { }",
      "    const licenseViolations = [];",
      "    // Placeholder: license resolution unknown ‚Üí flag for manual check",
      "    for (const c of sbom.components) {",
      "      const id = c.version && c.version !== 'UNKNOWN' ? `${c.name}@${c.version}` : c.name;",
      "      if (exceptions.includes(id) || exceptions.includes(c.name)) {",
      "        continue;",
      "      }",
      "      if (c.license && deny.includes(c.license)) {",
      "        licenseViolations.push({ name: c.name, version: c.version, license: c.license, type: 'deny' });",
      "      } else if (!c.license || (!allow.includes(c.license) && !deny.includes(c.license))) {",
      "        licenseViolations.push({ name: c.name, version: c.version, license: c.license || 'UNKNOWN', type: 'review' });",
      "      }",
      "    }",
      "",
      "    const reportsDir = 'reports';",
      "    if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });",
      "    const file = path.join(reportsDir, `sbom_${Date.now()}.json`);",
      "    fs.writeFileSync(file, JSON.stringify({ ...sbom, licenseViolations }, null, 2));",
      "",
      "    const result = {",
      "      success: true,",
      "      sbom_generated: true,",
      "      licenses_checked: true,",
      "      data: { components: sbom.components.length, report_path: file, license_violations: licenseViolations.length },",
      "      summary: `Generated SBOM with ${sbom.components.length} components`,",
      "      context: { ecosystems: ['npm', 'pypi'] }",
      "    };",
      "    if (verbose) console.log(JSON.stringify(result));",
      "    return result;",
      "  } catch (error) {",
      "    const fail = { success: false, error: String(error), sbom_generated: false, licenses_checked: false };",
      "    if (verbose) console.log(JSON.stringify(fail));",
      "    return fail;",
      "  }",
      "};",
      "",
      "export default { generateSbom };"
    ]
  },
  {
    "name": "secrets-scan.js",
    "size_bytes": 4176,
    "preview_lines": [
      "#!/usr/bin/env node",
      "import fs from 'fs';",
      "import path from 'path';",
      "",
      "const SECRET_PATTERNS = [",
      "    /aws(.{0,20})?(access|secret)[=_:\\s\"']+([A-Za-z0-9\\/+=]{20,})/ig,",
      "    /api[_-]?key[=_:\\s\"']+([A-Za-z0-9-_]{16,})/ig,",
      "    /secret[=_:\\s\"']+([A-Za-z0-9\\/+=]{12,})/ig,",
      "    /password[=_:\\s\"']+([^\\s\"']{6,})/ig,",
      "    /ghp_[A-Za-z0-9]{36,}/ig,",
      "    /AKIA[0-9A-Z]{16}/g",
      "];",
      "",
      "function globToRegExp(glob) {",
      "    const esc = glob.replace(/[.+^${}()|\\[\\]\\\\]/g, \"\\\\$&\").replace(/\\*\\*/g, \"[\\\\s\\\\S]*\").replace(/\\*/g, \"[^/\\\\\\\\]*\");",
      "    return new RegExp(\"^\" + esc + \"$\", \"i\");",
      "}",
      "",
      "function loadAllowlist() {",
      "    const allows = { ignoreFiles: [], ignorePatterns: [] };",
      "    try {",
      "        const p = path.join('config', 'security', 'secrets-allowlist.json');",
      "        if (fs.existsSync(p)) {",
      "            const j = JSON.parse(fs.readFileSync(p, 'utf8'));",
      "            if (Array.isArray(j.ignoreFiles)) allows.ignoreFiles = j.ignoreFiles;",
      "            if (Array.isArray(j.ignorePatterns)) allows.ignorePatterns = j.ignorePatterns.map(s => new RegExp(s, 'i'));",
      "        }",
      "    } catch { }",
      "    try {",
      "        const p2 = '.secretsignore';",
      "        if (fs.existsSync(p2)) {",
      "            const lines = fs.readFileSync(p2, 'utf8').split(/\\r?\\n/).map(s => s.trim()).filter(Boolean);",
      "            allows.ignoreFiles.push(...lines);",
      "        }",
      "    } catch { }",
      "    return allows;",
      "}",
      "",
      "function walk(dir, filelist = [], ignoreRes = []) {",
      "    const files = fs.readdirSync(dir, { withFileTypes: true });",
      "    for (const f of files) {",
      "        if (f.name.startsWith('.') || ['node_modules', 'venv', '.git'].includes(f.name)) continue;",
      "        const p = path.join(dir, f.name);",
      "        if (ignoreRes.some(rx => rx.test(p.replace(/\\\\/g, '/')))) continue;",
      "        if (f.isDirectory()) walk(p, filelist, ignoreRes); else filelist.push(p);",
      "    }",
      "    return filelist;",
      "}",
      "",
      "export const scanSecrets = async (context = {}) => {",
      "    const verbose = !context.entry_point;",
      "    try {",
      "        const root = process.cwd();",
      "        const allow = loadAllowlist();",
      "        const ignoreRes = allow.ignoreFiles.map(globToRegExp);",
      "        const files = walk(root, [], ignoreRes);",
      "        const findings = [];",
      "        for (const f of files) {",
      "            const ext = path.extname(f).toLowerCase();",
      "            if (['.png', '.jpg', '.jpeg', '.gif', '.pdf', '.lock', '.zip'].includes(ext)) continue;",
      "            let data = '';",
      "            try { data = fs.readFileSync(f, 'utf8'); } catch { continue; }",
      "            const isEnvFile = /(^|[\\\\/])(.env.*|.*\\.(env|ini|yaml|yml|cfg|conf|toml))$/i.test(f);",
      "            for (const re of SECRET_PATTERNS) {",
      "                re.lastIndex = 0;",
      "                let m;",
      "                while ((m = re.exec(data)) !== null) {",
      "                    const sample = m[0];",
      "                    if (allow.ignorePatterns.some(r => r.test(sample))) continue;",
      "                    const isKnownToken = /^ghp_[A-Za-z0-9]{36,}$/.test(sample) || /AKIA[0-9A-Z]{16}/.test(sample);",
      "                    const isSensitiveLabel = /(secret|token|api[_-]?key)/i.test(sample);",
      "                    const severity = (isKnownToken || (isEnvFile && isSensitiveLabel)) ? 'high' : 'medium';",
      "                    findings.push({ file: path.relative(root, f), pattern: re.source, sample: sample.slice(0, 64), severity });",
      "                }",
      "            }",
      "        }",
      "        const reportsDir = 'reports';",
      "        if (!fs.existsSync(reportsDir)) fs.mkdirSync(reportsDir, { recursive: true });",
      "        const out = path.join(reportsDir, `secrets_scan_${Date.now()}.json`);",
      "        fs.writeFileSync(out, JSON.stringify({ findings }, null, 2));",
      "        const highCount = findings.filter(f => f.severity === 'high').length;",
      "        const result = { success: true, secrets_scan_complete: true, findings_count: findings.length, high_count: highCount, report_path: out };",
      "        if (verbose) console.log(JSON.stringify(result));",
      "        return result;",
      "    } catch (e) {",
      "        const fail = { success: false, secrets_scan_complete: false, error: String(e) };",
      "        if (verbose) console.log(JSON.stringify(fail));",
      "        return fail;",
      "    }",
      "};",
      "",
      "export default { scanSecrets };"
    ]
  },
  {
    "name": "system-audit.js",
    "size_bytes": 24240,
    "preview_lines": [
      "#!/usr/bin/env node",
      "",
      "/**",
      " * Recursive System Audit Tool",
      " * ",
      " * Performs a comprehensive audit of the entire AZ Interface system,",
      " * mapping all connections and ensuring the Knowledge Hub is complete.",
      " */",
      "",
      "import fs from 'fs';",
      "import path from 'path';",
      "import { execSync } from 'child_process';",
      "",
      "class SystemAuditor {",
      "    constructor(context = {}) {",
      "        this.projectRoot = process.cwd();",
      "        this.context = context;",
      "        this.auditResults = {",
      "            files: {},",
      "            connections: {},",
      "            dependencies: {},",
      "            templates: {},",
      "            endpoints: {},",
      "            tools: {},",
      "            documentation: {},",
      "            missing: {},",
      "            recommendations: []",
      "        };",
      "    }",
      "",
      "    async performFullAudit() {",
      "        console.log('üîç Performing Full Recursive System Audit...');",
      "",
      "        try {",
      "            // Phase 1: File Discovery",
      "            await this.discoverAllFiles();",
      "",
      "            // Phase 2: Connection Mapping",
      "            await this.mapConnections();",
      "",
      "            // Phase 3: Dependency Analysis",
      "            await this.analyzeDependencies();",
      "",
      "            // Phase 4: Knowledge Hub Validation",
      "            await this.validateKnowledgeHub();",
      "",
      "            // Phase 5: Generate Recommendations",
      "            await this.generateRecommendations();",
      "",
      "            // Phase 6: Generate Audit Report",
      "            await this.generateAuditReport();",
      "",
      "            // Don't output to console when called from framework",
      "            if (!this.context || !this.context.entry_point) {",
      "                console.log('‚úÖ Full system audit completed!');",
      "            }",
      "",
      "        } catch (error) {",
      "            if (!this.context || !this.context.entry_point) {",
      "                console.error('‚ùå Error during system audit:', error);",
      "                process.exit(1);",
      "            } else {",
      "                throw error;",
      "            }",
      "        }",
      "    }",
      "",
      "    async discoverAllFiles() {",
      "        if (!this.context || !this.context.entry_point) {",
      "            console.log('üìÅ Phase 1: Discovering all files...');",
      "        }",
      "",
      "        const directories = [",
      "            'backend',",
      "            'src',",
      "            'tools',",
      "            'scripts',",
      "            'docs',",
      "            'consciousness',",
      "            'OCTOSPINE',",
      "            'Personas',",
      "            'a2a',",
      "            'crewai',",
      "            'monitoring',",
      "            'installer',",
      "            'config',",
      "            'internal'",
      "        ];",
      "",
      "        for (const dir of directories) {",
      "            if (fs.existsSync(dir)) {",
      "                await this.scanDirectoryRecursively(dir);",
      "            }",
      "        }",
      "",
      "        if (!this.context || !this.context.entry_point) {",
      "            console.log(`üìä Discovered ${Object.keys(this.auditResults.files).length} files`);",
      "        }",
      "    }",
      ""
    ]
  }
]